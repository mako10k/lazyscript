# 字句解析 (Lexing)

このドキュメントは lazyscript の字句仕様を示します。実装は `src/parser/lexer.l` にあり、Flex を用いて生成されます。

- コメント
  - 行コメント: `#` から行末まで無視
  - ブロックコメント: `{-` で開始し `-}` で終了。ネスト不可。
- 空白: スペース、タブ、改行は区切りとして無視
- 整数リテラル: 正の 10 進数 `[0-9]+` → トークン `LSTINT`
- 一般シンボル: `[a-zA-Z_][a-zA-Z0-9_]*` → `LSTSYMBOL`
- ドット付きシンボル: `.[a-zA-Z_][a-zA-Z0-9_]*` → `LSTDOTSYMBOL`
- 単引用識別子（quoted identifiers）:
  - コンストラクタ名: `'Name'` → `LSTSYMBOL`（引用内で `\'`, `\\`, `\n`, `\t`, `\r`, `\xHH`, 8進などを解釈）
  - ドット付きシンボル: `.'name'` → `LSTDOTSYMBOL`（先頭 `.` を含むシンボルとして扱う）
  - 参照シンボル: `~'name'` → `LSTREFSYM`
  - 備考: いずれも終端の `'` までがトークン。従来の英数字識別子よりも先にマッチするよう字句規則の順序を配置。
- 文字列リテラル: `"..."`。`\` によるエスケープをサポート (`\"` など)。→ トークン `LSTSTR`
- 演算子・記号
  - `->` → トークン `LSTARROW`
  - `!IDENT` → トークン `LSTENVOP`（環境 API シュガー。例: `!require`, `!import`）
  - その他 1 文字記号はリテラル文字として返却 (例: `(`, `)`, `[`, `]`, `,`, `:`, `|`, `~`, `{`, `}`, `=`, `;` など)

ドット記号と引用シンボルの方針（フォーマッタ連携）

- ドット記号 `.sym` は「メンバ名」専用のシンボル。フォーマッタは可能な限り引用を付けずに `.name` をそのまま出力する。
- 一般シンボル `'Name'` は字句として許可するが、名前空間キーやメンバ参照には `.name` を用いる。
- 参照 `~'Name'` やドット付き `.'name'` は字句としては認められるが、出力時は通常の `.name` へ正規化し、重複したドット（`..sym` など）を生成しない。

コメント保持ポリシー（フォーマッタ協調）

- レキサは行コメント/ブロックコメントを位置付きで収集し、プリンタが式の前後・行末に適切に挿入できるようストリーム化する。
- `.include` など行末コメントが続く文では、必ずセミコロンをコメントより前に配置する（例: `.include "x";  # comment`）。

位置情報: すべてのトークンで `YY_USER_ACTION` により `common/loc.h` の `lsloc_update` が呼ばれ、位置が更新されます。

メモリ管理: 生成コード内の `malloc/realloc/free` は GC ラッパ (`lsmalloc/lsrealloc/lsfree`) に置換されています。

注意: bash で `!{ ... }` や `!require` を `-e` で与える場合、ヒストリ展開に注意。シェル側でクォートして回避してください。
