# Type System Extensions（段階的移行計画）

本ドキュメントは、第一級の無名型構築子（type-level functions）と名前空間型（record-like types）の導入を、互換性を保ちながら段階的に進める現実的な移行計画を示します。実装は常にフラグ/オプトインで始め、既存コードを壊さない方針とします。

## 目的（Goals）
- 無名型構築子（%{ ... }）の導入により、型レベルの抽象化を可能にする。
- 名前空間を型レベルで表現（レコード型）し、メンバ利用の安全性を高める。
- 型検査は当面 Core IR の `--typecheck` 経路に限定し、徐々にカバレッジを拡張する。

## 非目的（Non-Goals / 当面やらない）
- 一足飛びの高度な型等価性や完全な HKTs 推論は対象外。
- 条件付き UNION の本格実装は後段。まずは閉じたレコード/行多相の導入を優先。

## 段階的移行（Phased Rollout）

### Phase 0: ガードレールと最小カインド
- 既定動作は従来どおり。新機能はフラグ/注釈経由のみ有効化。
- 最小カインド体系を定義: `Type` と `Type -> Type`（TyCon）。`Row` は後段で導入予定。
- 無名構築子の「同一性」は“生成的（nominal）”に定める（定義点IDを持つ）。

### Phase 1: 無名型構築子の内部表現と試験的注釈
- 仕様: `%{ ... }`（無名型構築子記述）、`%a`（型変数）を設計。
- 実装: まずは Core IR の `--typecheck` 内部に表現と検査を実装。言語表面構文は当面限定（コメントや外部メタデータで付与可）。
- 既存のアドホック構築子は、内部的に「カリー化された TyCon」に写像して扱う（互換維持）。
- 構築子変数環境 ΓC を導入し、初出時のアリティ/カインド推定と以後の整合性チェック（アリティ/カインド一致）を追加。

### Phase 2: 名前空間型（閉レコード）
- 仕様: シンボルキーのレコード `{ .k1: T1; .k2: T2; ... }` を導入。まずは“閉じた”形のみ。
- 対象: Prelude/標準ライブラリ（List/Option/Result/NS）の主要メンバに型注釈を段階付与。
- 検査: `--typecheck` でのフィールド存在/型一致検査。未注釈コードは従来どおり通す（警告止まり）。

### Phase 3: 公開構文の限定解禁（オプトイン）
- `%{ ... }` と `%a` の表面構文を「型注釈位置」に限定して解禁。プログラム本体は非注釈でも可。
- パターンで導入される構築子変数のスコープ/シャドウの診断（互換なら許容、非互換は警告→将来エラー）。
- エラーメッセージの最適化とドキュメント整備（書き方スニペットの提供）。

### Phase 4: 行多相（Row Polymorphism）の導入（オプション）
- 仕様: オープンレコード `{ .k1: T1; ... | ρ }` を導入し、フィールド拡張/合成を安全化。
- 運用: まずは型注釈でのみ利用可能。推論は最小限に抑える（明示注釈推奨）。

### Phase 5: 条件付き UNION（再検討）
- 要件: 実需/複雑度/実装コストを再評価。必要最小の形（合流点の限定）で試験導入を検討。

## 互換性とフォールバック
- 既存の任意名/任意引数の構築子は、内部的に `arg1 -> arg2 -> ... -> (a @ Constr args...)` に相当するカリー化 TyCon へ写像する。
- 構築子同値性は“定義点起源の名目（nominal）同値”のみを採用。異なる生成点は同値とみなさない。
- 既存コードはデフォルトで通る。新規型検査は `--typecheck` 指定時のみ厳格化。警告/エラーの閾値は `--no-kind-warn`/`--kind-error` など既存フラグで調整。

## 最終方針: 構築子変数（TyCon 変数）

最終的には、現在の代数構築子はすべて無名型構築子に置き換え、構築子名は「構築子変数（TyCon 変数）」として扱います。

- 環境分離
  - Γt: 項（値）変数環境
  - ΓC: 構築子（TyCon）変数環境（型レベル専用）
- 初出束縛（ゆるい束縛）
  - 構築子変数 C を初めて用いた位置で、適用回数からアリティ n を推定し、κ(C) = Type^n -> Type を割当。
  - 同時に C に生成的 ID を付与（名目同一性の起点）。
- 再出現の互換性チェック
  - 同名 C の以後の使用は、アリティ/カインドが初出と一致することを要求。違えば型エラー。
- パターンでの導入
  - `λ (C x y -> ...)` の C は、そのラムダのスコープで新規導入可能。
  - 外側に同名 C がある場合、互換（同アリティ/同カインド）なら許容、非互換は警告（将来エラー）または明示シャドウ注釈を要求。
- 値代入の禁止
  - ΓC の要素は TyCon に限る。`let C = 42` 等の値束縛は型エラー。

この設計により、構築子名は通常変数に準じたスコープ規則で運用しつつ、型レベル専用として安全に扱えます。

## 具体例（List の型の書き方の目安）

無名型構築子としての List（設計レベルの表記）:

```
List = %{
  %a -> {
    .cons: %a -> List %a -> List %a;
    .nil:  List %a;
  };
};
```

備考:
- `%{ ... }` は「無名型構築子の本体」を表し、`%a` は型変数。
- `{ .cons: ...; .nil: ... }` は“名前空間の型（閉レコード）”。
- 最初は注釈/ドキュメント用途に限定し、`--typecheck` で整合を検査。

### 構築子変数の例とエラー

```
# 初出で 2 引数適用 → arity=2 を推定
C a b    -- OK: κ(C) = Type -> Type -> Type に束縛

# 以後の単適用は不一致
C x      -- エラー: used with 1 arg, but first use fixed arity 2

# パターンでの導入（ローカル）
\ (C x -> ...)  -- ラムダ内で C を新規導入（外側 C と同名なら互換性チェック）

# 値代入は不可
let C = 42  -- エラー: constructor variable C is type-level; cannot assign a value
```

## エラーモデルとメッセージ方針
- カインド不一致: `expected Type -> Type, got Type` 等、期待/実際を明示。
- 不明フィールド: `unknown field .foo (available: .cons, .nil)` のように候補を提示。
- 閉レコード違反: 追加フィールドの存在を位置付きで報告。行多相導入後は提案（ρ 付与）を表示。
- アリティ不一致（構築子変数）: `constructor variable C used with 1 arg(s), but first use fixed arity 2`
- 名目衝突/シャドウ: `constructor variable C in this scope conflicts with outer C (different arity); shadowing requires explicit annotation`
- 値代入禁止: `C is a constructor variable (type-level); cannot assign a value`

## ロールアウト計画（実装順）
1) Core IR `--typecheck` に最小カインドと名目同値の導入（内部表現のみ）
2) 閉レコード検査の追加（Prelude/List/Option/Result/NS を優先）
3) 型注釈位置で `%{}`/`%a` を限定解禁（警告は軽め）
4) 行多相の試験導入（注釈限定、推論最小）
5) 条件付き UNION の要否評価と小規模 PoC

## テスト/運用
- 既存テストはそのまま。新機能は `test/typecheck/` 配下などに別系統を追加。
- CI では `--typecheck` を追加ジョブとして実行し、警告を集計（将来的に閾値で失敗化）。

## 用語と前提
- Kind: `Type` / `Type -> Type`（当面）。
- 名目同値: 無名構築子は定義点IDでもって区別され、構成が同じでも別物。
- 名前空間型: シンボルキーのレコード。まずは閉じた形から。

---

この計画に従い、実装は常に“実用最小”から着手し、段階ごとにドキュメント/エラーメッセージ/テストの整備を伴走させます。既存コードの破壊的変更は避け、明示的なフラグで新機能を試せる状態を継続します。