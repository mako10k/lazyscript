# 型付け仕様（改訂）

本仕様は Core IR に対する型の扱いを「代数値と型の分離」から「アドホックな TyCon 形」へ改訂します。CLI フラグ `--typecheck` は本仕様に従って結果を報告します。

- 成功時: `OK` を1行で出力、終了コード 0
- 失敗時: `E: type error` を1行で出力、終了コード 1

## 型の表現

- 型は TyCon(name, [args]) により表す（アドホック）。
  - 例: `Int` は `TyCon("Int", [])`、`Str` は `TyCon("Str", [])`、`Unit` は `TyCon("Unit", [])`。
  - 関数は「未確定/部分適用を許す」ため、まずは Arity で近似。適用規則で確定する。
- 未確定は `Unknown`（内部表現）として保持し、適用や WHNF 観測で確定させる。

## 代数値とオーバーロード

- 代数（コンストラクタ）はオーバーロードを許容する（緩い実装）。
- 解決はまず Arity でふるい分け、同名で Arity が異なる候補は「適用で」決定される。
- `True 3 "123"` のような用法も表現可能だが、型 `True` と値 `True` は意味が異なる（名前が同じでもセマンティクスは型側で別物）。
- 将来、Arity の微妙な差で問題が出る場合は、その時点で解決戦略を強化する。

## 適用規則（Arity 近似と確定）

- 候補が `arity = k` のとき、引数 `m` を適用：
  - `m > k` なら型エラー（過剰適用）。
  - `m == k` なら結果は値型（WHNF 的に確定）。
  - `m < k` なら「残り `k-m` 引数を受ける関数」扱い（未確定/部分適用）。
- Arity が明確に異なる場合は型エラー。推論で Arity が確定すれば、その型として決定。

## 内部型: IO

- `@IO` は内部専用の型コンストラクタ（例: `TyCon("@IO", [a])`）。
- 通常のパターンマッチで取り出すことはできない。生成・観察はビルトイン経由のみ。
- 型検査では `@IO` を一般の TyCon と同様に扱うが、パターン側での使用を拒否する（エラー）。

## 特殊コンストラクタ: #int / #str

- `#int N` は整数 `N` の生成兼マッチ、`#str S` は文字列 `S` の生成兼マッチ。
- パターン位置では等値マッチ（既存の INT/STR パターンと同等）。式位置ではリテラル生成の糖衣。
- 型はそれぞれ `Int` / `Str`。

## 互換性（今回の改訂を優先）

- 過去の「最小タイプチェック（引数個数のみ）」仕様より本改訂を優先する。
- 既存の構文・評価器は維持し、型検査段で Arity と TyCon 表現を導入して判定する。

## 実装フェーズ（段階導入）

1. 型表現と Arity チェックの導入（Core IR 型検査）
   - TyCon/Unknown を内部に追加し、適用時の Arity 規則を実装。
   - 代数のオーバーロードは Arity ベースで解決。

2. `@IO` と `#int/#str` の取り扱い
   - `@IO` の生成/観察をビルトインに限定、パターンでの観察はエラー。
   - `#int/#str` 構文糖衣（パーサ）とその型付け・マッチングを追加。

## テスト

- 既存: `test/t01_add.type.out`（OK）、`test/t14_type_arity_error.*`（過剰適用エラー）
- 追加予定: `#int/#str`、`@IO` パターン禁止、Arityでのオーバーロード解決のスモールケース。

## 既知の制限

- 引数や戻り値の精密な型整合性は未実装（Arity中心）。
- `if` 等分岐整合性、ラムダの本格的推論は将来対応。
