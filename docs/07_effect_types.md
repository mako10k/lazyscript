# 型コンストラクタと値コンストラクタの分離（設計メモ）

目標: Haskell 風に「型コンストラクタ（種レベル）」と「値コンストラクタ（項レベル）」を分離し、IO の外部化/封入を保ちつつ値の取り出しを禁止する規律を導入する。

現状まとめ（2025-08-18）
- Core IR の `VAL_CONSTR` は 0 引数の `()` を含む単純な値コンストラクタ表現のみ。
- パターンマッチ/ユーザ定義データ型は未実装。
- タイプチェックは最小版で Arity 中心。コンストラクタの型検査は未導入。
- 効果規律は `--strict-effects` とトークン（`Token`/`EffApp`）で別途検証。

設計方針
1. 種（Kind）と型コンストラクタ
   - 種 `*` と `* -> *` を最小限導入し、`IO :: * -> *` を表現。
   - 型環境に `add :: Int -> Int -> Int` などの「型だけ」のシグネチャを保持。
2. 値コンストラクタ
   - 値レベルのコンストラクタ（例: `Unit`, `True`, `False`, ユーザ定義）は従来通り値として現れる。
   - `match/case` の導入は後段。まずはコンストラクタの arity とタグのみを型環境で管理。
3. IO の外部化
   - Core IR の `EffApp` と `Token` によるシーケンス規律を維持。
   - 型付けでは `EffApp f args : IO Unit` という一貫した見た目を目指すが、最小段では `Unit` 近似でもよい。
4. 禁止事項
   - `IO a` から `a` を直接取り出す演算は提供しない。
   - `bind :: IO a -> (a -> IO b) -> IO b`、`return :: a -> IO a` のみを入口/出口とし、`chain :: IO () -> (() -> IO b) -> IO b` は `a ~ ()` の特殊形とみなす。

段階的な実装ステップ
- S1: 型シグネチャ環境（プリミティブのみ）を導入し、`add/sub/return/chain` を `fun` の結果型まで区別（例: `return :: a -> IO a`）。最小版では `IO` は表示上のタグだけ（実装は `Token` 規律のまま）。
- S2: `--typecheck` に `IO` 整合性を追加（`EffApp`/`Token` を `IO` として扱い、`bind` の型則を反映）。
- S3: Core IR に `Match` を追加し、コンストラクタ arity/タグ検査（型環境と連動）。
- S4: ユーザ定義データ型宣言（表層構文→型環境登録）を追加。

補足
- 互換性のため、既存コードは `Unit` 近似/トークン規律で動作を維持。チェックのみ段階的に強化。
- `--strict-effects` は構文規律、`--typecheck` は型規律として併用可能にする。

## Kindだけで進める実務的モード（当面の折衷案）

「型/値コンストラクタの完全分離」は型定義や宣言が必要になりがちで重いので、まずは Kind ベースの軽量チェックだけを導入する運用も可能です。

- 最低限の取り決め
   - 値は Kind `*`。
   - エフェクト計算は概念的に Kind `IO *`（実装上は Core IR の `EffApp`/`Token` に対応）。
   - `return`/`bind`/`chain` は値（`*`）だが、「IO計算（EffApp/Tokenに依存）」をつなぐための接着として扱う。
- チェックの粒度（軽量）
   - すでにある `--strict-effects` が「トークン規律」を構文的に保証。
   - `--typecheck` は当面 Arity中心のまま据え置き、将来「明らかに純な文脈に `EffApp` が生で現れる」ケースを警告する程度の Kind チェックを追加可能。
- メリット
   - 型定義・宣言を導入せずに、概念的な IO の外部化を維持できる。
   - 実装コストを抑えながら、将来の本格的な型システム導入に備えられる。

この「Kindだけ」モードでも、「IOからの値取り出し」を言語機能として提供しない限り、実質的に取り出しは禁止のまま（Core IR 上もトークン規律で封じている）です。型システム側の強制は後段で追加していく方針とします。
