# List 構文とライブラリ化の計画（メモ）

目的
- List はプリミティブ型にせず、代数値（値コンストラクタ）で表現する方針を維持。
- ただしユーザ体験向上のため、式/パターンでの List 構文（糖衣）を導入。
- 既存のネイティブ関数（cons/is_nil/head/tail/length/concat）は段階的に .ls ライブラリへ移行。

現状（2025-08-19）
- 実行表現: 値コンストラクタ `[]`/`:`（別名 `Nil`/`Cons`）でリストを表現。プリンタはこれを [a, b, ...] で表示。
- 実装上の便宜として cons/is_nil/head/tail/length/concat をネイティブで提供（要素型は不問）。
- 型検査は Arity中心（List a の整合性検査は未導入）。
- AST/パーサには List 構文は未実装。

計画
1) 構文糖衣（式）
   - リテラル: `[e1, e2, ..., en]` を `:(e1, :(e2, ...(:(en, [])...)))` にデシュガー。
   - 連結（二項演算子）は当面見送り。連結は関数 `concat xs ys` を直接呼ぶ想定。

2) 構文糖衣（パターン）
   - `[]` パターン: そのまま `[]` へ。
   - `x : xs` パターン: `:(x, xs)` にデシュガー（注意: `[x|xs]` は OR パターンと衝突するため採用しない）。
   - `[p1, p2, ..., pn]` パターン: `:(p1, :(p2, ...(:(pn, [] )...)))` にデシュガー。

3) 命名ポリシー（ユーザ定義との衝突回避）
   - ユーザが `Nil`/`Cons` を別用途で定義可能である点に配慮し、構文糖衣の展開先は記号コンストラクタ `[]` と `:` を用いる（英字名は使わない）。
   - `[]`/`:` は「構文糖衣の展開先として予約」するが、通常名空間に新たな予約語は増やさない（ユーザが同名を使う強い理由は稀）。
   - さらに衝突を避けたい場合は、将来的に `--sugar-namespace` を活用し、演算子糖衣をその名前空間の関数に展開する設計余地あり（例: `++` → `~list.concat`）。現段階では二項演算子は未導入。

4) ライブラリ化
   - `list.ls`（プレリュード）を追加し、以下を提供:
     - `cons`, `is_nil`, `head`, `tail`, `length`, `concat`（内部では `[]`/`:` に基づく再帰で実装）
   - ネイティブ版は当面残し、段階的に `.ls` 実装へ移行。移行完了後、ネイティブは非推奨化（互換のためしばらく共存）。

5) 型との関係
   - 直近は Arity中心で List 要素型の整合は未拘束（混在要素を許容）。
   - 将来、TyCon ベースで `List a` を導入し、段階的に一致検査/警告を強化（ただし既存コード破壊を避けるため警告から開始）。

6) テスト
   - 式: `concat [1, 2] ["x"]` が `:(1, :(2, :("x", [])))` に評価されること。
   - パターン: `case xs of [] -> ... | [x|xs] -> ...` のデシュガー正当性。
   - ライブラリ: `length`, `concat` の `.ls` 実装がネイティブと同等に振る舞うこと。

実装段取り
- 先にドキュメント合意（本メモ）。
- パーサ: `[]`, `[e,..]`, `x : xs`, `[p1,..,pn]` の導入（優先度表へ追加）。
- ライブラリ: `list.ls` 追加、テスト作成。既存ネイティブは並存。
- 後続: `.ls` 実装への移行スイッチ、ネイティブの段階的縮退。二項 `++` は後段で検討。
